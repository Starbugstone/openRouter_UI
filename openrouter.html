<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>OpenRouter Mini Playground (v5 – robust streaming)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
    body { margin: 0; background:#0b0c10; color:#e8eaed; }
    .wrap { max-width: 880px; margin: 24px auto; padding: 0 16px; }
    h1 { margin: 0 0 8px; font-size: 24px; }
    .card { background:#111318; border:1px solid #23262e; border-radius: 12px; padding: 16px; margin: 16px 0; }
    label { display:block; font-size: 13px; color:#b6b9c3; margin-bottom: 6px; }
    input[type="text"], input[type="password"], textarea, select, input[type="number"] {
      width: 100%; padding: 10px 12px; background:#0e1015; color:#e8eaed; border:1px solid #2a2e37; border-radius: 8px;
    }
    #modelSearch {
      font-size: 14px;
      background: #0e1015;
      color: #e8eaed;
      border: 1px solid #2a2e37;
      border-radius: 8px;
      padding: 8px 12px;
    }
    #modelSearch:focus {
      outline: none;
      border-color: #2d7cff;
      box-shadow: 0 0 0 2px rgba(45, 124, 255, 0.2);
    }
    #model {
      background: #0e1015;
      color: #e8eaed;
      border: 1px solid #2a2e37;
    }
    #model option {
      background: #0e1015;
      color: #e8eaed;
    }
    textarea { resize: vertical; min-height: 90px; }
    .row { display:flex; gap:12px; flex-wrap:wrap; }
    .row > * { flex: 1 1 240px; }
    .btn { cursor:pointer; background:#2d7cff; color:white; border:none; padding:10px 14px; border-radius:10px; font-weight:600; }
    .btn.secondary { background:#21242c; color:#e8eaed; border:1px solid #2a2e37; }
    .actions { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    pre.out { white-space: pre-wrap; word-wrap: break-word; background:#0e1015; border:1px solid #2a2e37; border-radius:8px; padding:12px; min-height: 80px;}
    .muted { color:#9aa0aa; font-size: 12px; }
    .imgs { display:grid; grid-template-columns: repeat(auto-fill,minmax(180px,1fr)); gap:12px; }
    .imgs img { width:100%; height:auto; border-radius:10px; border:1px solid #2a2e37; background:#0e1015; cursor:pointer; transition:opacity 0.2s; }
    .imgs img:hover { opacity:0.8; }
    
    /* Modal styles */
    .modal { display:none; position:fixed; z-index:1000; left:0; top:0; width:100%; height:100%; background-color:rgba(0,0,0,0.9); }
    .modal-content { margin:auto; display:block; max-width:90%; max-height:90%; object-fit:contain; }
    .modal-close { position:absolute; top:15px; right:35px; color:#f1f1f1; font-size:40px; font-weight:bold; cursor:pointer; }
    .modal-close:hover, .modal-close:focus { color:#bbb; text-decoration:none; }
    .modal-caption { margin:auto; display:block; width:80%; max-width:700px; text-align:center; color:#ccc; padding:10px 0; height:150px; }
    .switch { display:flex; gap:12px; }
    .switch label { margin: 0; }
    .pill { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; border:1px solid #2a2e37; background:#0e1015; font-size:12px; }
    .small { font-size:12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>OpenRouter Mini Playground (v3)</h1>
    <div class="muted small">
      Serve this over <strong>http://localhost</strong> (not <code>file://</code>) so the browser sends a proper Origin/Referer.
    </div>

    <div class="card">
      <div class="row">
        <div>
          <label>OpenRouter API Key</label>
          <input id="apiKey" type="password" placeholder="sk-or-v1-..." />
          <div class="switch" style="margin-top:8px">
            <label class="pill"><input id="rememberKey" type="checkbox" /> Remember key (localStorage)</label>
          </div>
        </div>
        <div>
          <label>Mode</label>
          <select id="mode">
            <option value="text">Text (Chat Completions)</option>
            <option value="image">Image Generation (via Chat + modalities)</option>
          </select>
        </div>
      </div>

      <div class="row" style="margin-top:12px">
        <div>
          <label>Model Selection</label>
          <div style="position: relative;">
            <input id="modelSearch" type="text" placeholder="Search free models..." style="margin-bottom: 8px;" />
            <select id="model" style="width: 100%;">
              <option value="">Loading models...</option>
            </select>
          </div>
          <div class="muted small" style="margin-top:6px">
            <strong>Free Models:</strong> <span id="modelCount">Loading...</span> available free models. 
            <button type="button" id="refreshModels" class="btn secondary" style="padding: 4px 8px; font-size: 11px; margin-left: 8px;">Refresh</button><br/>
            <strong>Note:</strong> Multiple images (n>1) may not be supported by all models. Google Gemini typically generates 1 image per request.
          </div>
        </div>
        <div id="imageOptions" style="display:none">
          <label>Number of images (best-effort)</label>
          <input id="imgCount" type="number" min="1" max="4" value="1" />
        </div>
      </div>

      <div class="row" style="margin-top:12px">
        <div>
          <label>Prompt</label>
          <textarea id="prompt" placeholder="Describe the image you want, or type a normal text prompt..."></textarea>
        </div>
      </div>

      <div class="actions" style="margin-top:12px">
        <button class="btn" id="runBtn">Run</button>
        <button class="btn secondary" id="stopBtn">Stop</button>
        <button class="btn secondary" id="clearBtn">Clear</button>
        <label class="pill"><input id="stream" type="checkbox" checked /> Stream</label>
        <label class="pill">Timeout (s): <input id="timeoutSec" type="number" min="5" max="120" value="30" style="width:64px;background:transparent;border:none;color:#e8eaed"/></label>
        <span class="muted small">If a stream hangs, use <em>Stop</em> or disable streaming.</span>
      </div>
    </div>

    <div class="card">
      <label>Output</label>
      <pre id="textOut" class="out"></pre>
      <div id="images" class="imgs"></div>
    </div>

    <!-- Modal for full-screen image viewing -->
    <div id="imageModal" class="modal">
      <span class="modal-close">&times;</span>
      <img class="modal-content" id="modalImage">
      <div id="modalCaption" class="modal-caption"></div>
    </div>

    <div class="muted small">
      Docs: <a href="https://openrouter.ai/docs/quickstart" target="_blank" rel="noopener">Quickstart</a> ·
      <a href="https://openrouter.ai/docs/features/multimodal/image-generation" target="_blank" rel="noopener">Image Gen via chat</a> ·
      <a href="https://openrouter.ai/models" target="_blank" rel="noopener">Models</a>
    </div>
  </div>

<script>
(function(){
  var $ = function(id){ return document.getElementById(id); };
  var apiKeyEl = $("apiKey");
  var rememberEl = $("rememberKey");
  var modeEl = $("mode");
  var modelEl = $("model");
  var promptEl = $("prompt");
  var runBtn = $("runBtn");
  var stopBtn = $("stopBtn");
  var clearBtn = $("clearBtn");
  var textOut = $("textOut");
  var imgWrap = $("images");
  var streamEl = $("stream");
  var imageOptions = $("imageOptions");
  var imgCountEl = $("imgCount");
  var timeoutEl = $("timeoutSec");
  var modal = $("imageModal");
  var modalImg = $("modalImage");
  var modalCaption = $("modalCaption");
  var modelSearchEl = $("modelSearch");
  var modelCountEl = $("modelCount");
  var refreshModelsBtn = $("refreshModels");

  var currentController = null;
  var streamingActive = false;
  var timeoutHandle = null;
  var allModels = [];
  var freeModels = [];

  try {
    var saved = localStorage.getItem("or_api_key");
    if (saved) { apiKeyEl.value = saved; rememberEl.checked = true; }
  } catch (e) {}

  rememberEl.addEventListener("change", function(){
    try {
      if (rememberEl.checked) localStorage.setItem("or_api_key", apiKeyEl.value || "");
      else localStorage.removeItem("or_api_key");
    } catch(e){}
  });
  apiKeyEl.addEventListener("input", function(){
    try { if (rememberEl.checked) localStorage.setItem("or_api_key", apiKeyEl.value || ""); } catch(e){}
  });

  modeEl.addEventListener("change", function(){
    var isImage = modeEl.value === "image";
    imageOptions.style.display = isImage ? "block" : "none";
    textOut.textContent = "";
    imgWrap.innerHTML = "";
  });

  clearBtn.addEventListener("click", function(){
    textOut.textContent = "";
    imgWrap.innerHTML = "";
  });

  stopBtn.addEventListener("click", function(){
    abortActive("Stopped by user");
  });

  window.addEventListener("beforeunload", function(){ abortActive("Unload"); });

  // Modal functionality
  var closeBtn = document.querySelector(".modal-close");
  
  // Close modal when clicking the X
  closeBtn.addEventListener("click", function(){
    modal.style.display = "none";
  });
  
  // Close modal when clicking outside the image
  modal.addEventListener("click", function(event){
    if (event.target === modal) {
      modal.style.display = "none";
    }
  });
  
  // Close modal with Escape key
  document.addEventListener("keydown", function(event){
    if (event.key === "Escape" && modal.style.display === "block") {
      modal.style.display = "none";
    }
  });

  // Fetch and populate models
  function fetchModels() {
    fetch('https://openrouter.ai/api/v1/models')
      .then(function(response) {
        if (!response.ok) {
          throw new Error('Failed to fetch models: ' + response.status);
        }
        return response.json();
      })
      .then(function(data) {
        allModels = data.data || [];
        // Filter for free models (both prompt and completion pricing are "0")
        freeModels = allModels.filter(function(model) {
          var pricing = model.pricing || {};
          return pricing.prompt === "0" && pricing.completion === "0";
        });
        
        // Sort models by name for better UX
        freeModels.sort(function(a, b) {
          return a.name.localeCompare(b.name);
        });
        
        populateModelDropdown();
        modelCountEl.textContent = freeModels.length;
        console.log('Loaded ' + freeModels.length + ' free models');
      })
      .catch(function(error) {
        console.error('Error fetching models:', error);
        modelEl.innerHTML = '<option value="">Error loading models</option>';
        modelCountEl.textContent = 'Error';
      });
  }

  function populateModelDropdown() {
    modelEl.innerHTML = '<option value="">Select a free model...</option>';
    
    freeModels.forEach(function(model) {
      var option = document.createElement('option');
      option.value = model.id;
      option.textContent = model.name + ' (' + model.id + ')';
      modelEl.appendChild(option);
    });
  }

  function filterModels() {
    var searchTerm = modelSearchEl.value.toLowerCase();
    var options = modelEl.options;
    
    for (var i = 0; i < options.length; i++) {
      var option = options[i];
      var text = option.textContent.toLowerCase();
      option.style.display = text.includes(searchTerm) ? '' : 'none';
    }
  }

  // Add search functionality
  modelSearchEl.addEventListener('input', filterModels);

  // Add refresh button functionality
  refreshModelsBtn.addEventListener('click', function() {
    modelCountEl.textContent = 'Loading...';
    modelEl.innerHTML = '<option value="">Loading models...</option>';
    fetchModels();
  });

  // Load models on page load
  fetchModels();

  runBtn.addEventListener("click", function(){
    var key = (apiKeyEl.value || "").trim();
    var mode = modeEl.value;
    var model = (modelEl.value || "").trim() || (mode === "image" ? "google/gemini-2.5-flash-image-preview" : "openrouter/auto");
    var prompt = (promptEl.value || "").trim();

    if (!key) { alert("Please paste your OpenRouter API key."); return; }
    if (!prompt) { alert("Please write a prompt."); return; }

    textOut.textContent = "";
    imgWrap.innerHTML = "";

    var n = 1; if (mode === "image"){ n = parseInt(imgCountEl.value || 1, 10); if (isNaN(n)) n = 1; n = Math.min(Math.max(n,1),4); }

    var doStream = !!streamEl.checked;
    var tsec = parseInt(timeoutEl.value || 30, 10); if (isNaN(tsec)) tsec = 30; tsec = Math.min(Math.max(tsec,5),120);

    // Warn if trying to generate multiple images with Google Gemini
    if (mode === "image" && n > 1 && model.toLowerCase().includes("gemini")) {
      console.warn("Warning: Google Gemini models typically only generate 1 image per request, regardless of the 'n' parameter.");
    }

    if (mode === "text") {
      runChat(key, model, prompt, doStream, tsec).catch(reportErr);
    } else {
      runImageViaChat(key, model, prompt, n, doStream, tsec).catch(reportErr);
    }
  });

  function reportErr(err){
    console.error(err);
    var msg = (err && err.message) ? err.message : String(err);
    textOut.textContent = (textOut.textContent ? textOut.textContent + "\n" : "") + "Error: " + msg;
    cleanupStreamState();
  }

  function beginStream(){
    abortActive();
    currentController = new AbortController();
    streamingActive = true;
    var tsec = parseInt(timeoutEl.value || 30, 10); if (isNaN(tsec)) tsec = 30;
    clearTimeout(timeoutHandle);
    timeoutHandle = setTimeout(function(){ abortActive("Timed out"); }, tsec * 1000);
    stopBtn.disabled = false;
    runBtn.disabled = true;
  }

  function cleanupStreamState(){
    streamingActive = false;
    clearTimeout(timeoutHandle);
    timeoutHandle = null;
    runBtn.disabled = false;
    stopBtn.disabled = true;
  }

  function abortActive(reason){
    if (currentController){ try { currentController.abort(); } catch(e){} }
    currentController = null;
    if (reason){ textOut.textContent = (textOut.textContent ? textOut.textContent + "\n" : "") + "[Stream closed: " + reason + "]"; }
    cleanupStreamState();
  }

  function getHeader(res, name){
    try { return res.headers.get(name) || ""; } catch(e){ return ""; }
  }

  function pickText(message){
    if (!message) return "";
    if (typeof message.content === 'string') return message.content;
    if (message.content && message.content.length){
      var parts = [];
      for (var i=0;i<message.content.length;i++){
        var p = message.content[i];
        if (p && p.type === 'output_text' && p.text) parts.push(p.text);
      }
      return parts.join('');
    }
    return "";
  }

  function extractImagesFromMessage(message){
    var out = [];
    if (!message) return out;
    if (message.content && message.content.length){
      for (var i=0;i<message.content.length;i++){
        var p = message.content[i];
        if (p && p.type === 'output_image' && p.image_url && p.image_url.url){ 
          out.push(p.image_url.url); 
        }
      }
    }
    if (message.images && message.images.length){
      for (var j=0;j<message.images.length;j++){
        var im = message.images[j];
        if (im && im.image_url && im.image_url.url) {
          out.push(im.image_url.url);
        }
      }
    }
    return out;
  }

  function addImg(src){
    console.log("Adding image:", src.substring(0, 50) + "...");
    var img = document.createElement("img");
    img.src = src; 
    img.alt = "Generated image";
    img.onload = function(){ 
      console.log("Image loaded successfully");
      // Add a visual indicator that an image was loaded
      if (imgWrap.children.length === 1) {
        textOut.textContent += "\n[Image loaded successfully]";
      }
    };
    img.onerror = function(){ 
      console.error("Image failed to load:", src);
      textOut.textContent += "\n[Image failed to load]";
    };
    
    // Add click handler to open modal
    img.addEventListener("click", function(){
      modalImg.src = src;
      modalCaption.textContent = "Generated image - Click outside or press Escape to close";
      modal.style.display = "block";
    });
    
    imgWrap.appendChild(img);
  }

  function parseJsonOrThrow(res){
    return res.text().then(function(text){
      var ct = getHeader(res, "content-type");
      if (ct.indexOf("application/json") === -1){
        throw new Error("Expected JSON but got \"" + ct + "\". Status " + res.status + ". Body:\n" + text.slice(0,1000));
      }
      try { return JSON.parse(text); }
      catch(e){ throw new Error("Failed to parse JSON. Status " + res.status + ". Body (truncated):\n" + text.slice(0,1000)); }
    });
  }

  function readSSE(res, onChunk, onDone){
    if (!res.ok){
      return res.text().then(function(t){ throw new Error("HTTP " + res.status + " – " + (t||"")); });
    }

    var ct = getHeader(res, "content-type");
    if (ct.indexOf("text/event-stream") === -1){
      // Not a stream, fall back to JSON
      return parseJsonOrThrow(res).then(function(json){ onChunk({ json: json, fallback: true }); if (onDone) onDone(); });
    }

    var reader = res.body.getReader();
    var decoder = new TextDecoder("utf-8");
    var buffer = "";

    function pump(){
      return reader.read().then(function(step){
        if (step.done){ if (onDone) onDone(); return; }
        buffer += decoder.decode(step.value, { stream: true });
        var idx;
        while ((idx = buffer.indexOf("\n\n")) !== -1){
          var chunk = buffer.slice(0, idx);
          buffer = buffer.slice(idx + 2);
          var lines = chunk.split("\n");
          for (var i=0;i<lines.length;i++){
            var line = lines[i].trim();
            if (line.indexOf("data:") !== 0) continue;
            var data = line.slice(5).trim();
            if (data === "[DONE]") { if (onDone) onDone(); return; }
            try { var obj = JSON.parse(data); onChunk(obj); } catch(e){}
          }
        }
        return pump();
      }).catch(function(err){ if (onDone) onDone(err); });
    }
    return pump();
  }

  function runChat(key, model, prompt, stream, tsec){
    var body = { model: model, messages: [{ role: "user", content: prompt }], stream: stream };
    var url = "https://openrouter.ai/api/v1/chat/completions";

    if (!stream){
      return fetch(url, {
        method: "POST",
        headers: {
          "Authorization": "Bearer " + key,
          "Content-Type": "application/json",
          "Accept": "application/json",
          "X-Title": "Local OpenRouter Playground"
        },
        body: JSON.stringify(body)
      }).then(parseJsonOrThrow).then(function(json){
        var content = pickText(json.choices && json.choices[0] && json.choices[0].message) || "";
        textOut.textContent = content || "[Empty response]";
      });
    }

    beginStream();
    return fetch(url, {
      method: "POST",
      headers: {
        "Authorization": "Bearer " + key,
        "Content-Type": "application/json",
        "Accept": "text/event-stream",
        "X-Title": "Local OpenRouter Playground"
      },
      body: JSON.stringify(body),
      signal: currentController.signal
    }).then(function(res){
      return readSSE(res, function(chunk){
        if (chunk && chunk.json && chunk.fallback){
          // server returned JSON instead of SSE
          var content = pickText(chunk.json.choices && chunk.json.choices[0] && chunk.json.choices[0].message) || "";
          textOut.textContent = content || "[Empty response]";
          return;
        }
        var choice = chunk.choices && chunk.choices[0];
        var fin = choice ? choice.finish_reason : null;
        if (fin === "content_filter"){ textOut.textContent += "\n[Blocked by content filter]"; }
        var delta = choice ? choice.delta : null;
        if (delta && typeof delta.content === 'string'){ textOut.textContent += delta.content; }
        if (delta && delta.content && delta.content.length){
          for (var i=0;i<delta.content.length;i++){
            var part = delta.content[i];
            if (part && part.type === 'output_text' && part.text){ textOut.textContent += part.text; }
            if (part && part.type === 'output_image' && part.image_url && part.image_url.url){ addImg(part.image_url.url); }
          }
        }
      }, function(){ cleanupStreamState(); });
    }).catch(function(err){ cleanupStreamState(); throw err; });
  }

  function runImageViaChat(key, model, prompt, n, stream, tsec){
    var body = { model: model, messages: [{ role: "user", content: prompt }], modalities: ["image","text"], n: n, stream: stream };
    var url = "https://openrouter.ai/api/v1/chat/completions";
    
    // Debug: Log the request being sent
    console.log("Sending image generation request:", JSON.stringify(body, null, 2));

    if (!stream){
      return fetch(url, {
        method: "POST",
        headers: {
          "Authorization": "Bearer " + key,
          "Content-Type": "application/json",
          "Accept": "application/json",
          "X-Title": "Local OpenRouter Playground"
        },
        body: JSON.stringify(body)
      }).then(parseJsonOrThrow).then(function(json){
        // Process all choices for multiple images
        var totalImages = 0;
        if (json.choices && json.choices.length > 0) {
          for (var c = 0; c < json.choices.length; c++) {
            var message = json.choices[c] && json.choices[c].message;
            var imgs = extractImagesFromMessage(message);
            for (var i=0;i<imgs.length;i++) {
              addImg(imgs[i]);
              totalImages++;
            }
          }
        }
        if (totalImages === 0) {
          var txt = pickText(json.choices && json.choices[0] && json.choices[0].message);
          textOut.textContent = txt ? txt : "No images found in response.";
        }
      });
    }

    beginStream();
    return fetch(url, {
      method: "POST",
      headers: {
        "Authorization": "Bearer " + key,
        "Content-Type": "application/json",
        "Accept": "text/event-stream",
        "X-Title": "Local OpenRouter Playground"
      },
      body: JSON.stringify(body),
      signal: currentController.signal
    }).then(function(res){
      return readSSE(res, function(chunk){
        // Debug logging for image chunks
        if (chunk && chunk.choices) {
          console.log("Image streaming chunk:", JSON.stringify(chunk, null, 2));
        }
        
        if (chunk && chunk.json && chunk.fallback){
          // Handle non-streaming response
          if (chunk.json.choices && chunk.json.choices.length > 0) {
            for (var c = 0; c < chunk.json.choices.length; c++) {
              var message = chunk.json.choices[c] && chunk.json.choices[c].message;
              var imgs = extractImagesFromMessage(message);
              for (var i=0;i<imgs.length;i++) addImg(imgs[i]);
            }
            if (imgWrap.children.length === 0) {
              var txt = pickText(chunk.json.choices[0] && chunk.json.choices[0].message);
              textOut.textContent = txt ? txt : "No images found in response.";
            }
          }
          return;
        }
        
        // Handle streaming response - process all choices
        if (chunk && chunk.choices && chunk.choices.length > 0) {
          for (var choiceIndex = 0; choiceIndex < chunk.choices.length; choiceIndex++) {
            var choice = chunk.choices[choiceIndex];
            var fin = choice ? choice.finish_reason : null;
            if (fin === "content_filter"){ 
              textOut.textContent += "\n[Blocked by content filter]"; 
            }
            var delta = choice ? choice.delta : null;
            
            // Check for images in the choice itself (not just delta content)
            if (choice && choice.message && choice.message.images){
              console.log("Found images in choice.message.images:", choice.message.images);
              for (var k=0;k<choice.message.images.length;k++){
                var img = choice.message.images[k];
                if (img && img.image_url && img.image_url.url){
                  console.log("Adding image from choice.message.images:", img.image_url.url);
                  addImg(img.image_url.url);
                }
              }
            }
            
            // Check for images in delta.images (the actual structure from the API)
            if (delta && delta.images && delta.images.length){
              console.log("Found images in delta.images:", delta.images);
              for (var m=0;m<delta.images.length;m++){
                var img = delta.images[m];
                if (img && img.type === 'image_url' && img.image_url && img.image_url.url){
                  console.log("Adding image from delta.images:", img.image_url.url);
                  addImg(img.image_url.url);
                }
              }
            }
            
            if (delta && delta.content && delta.content.length){
              for (var i=0;i<delta.content.length;i++){
                var part = delta.content[i];
                if (part && part.type === 'output_text' && part.text){ textOut.textContent += part.text; }
                if (part && part.type === 'output_image' && part.image_url && part.image_url.url){ 
                  console.log("Adding image from delta content:", part.image_url.url);
                  addImg(part.image_url.url); 
                }
              }
            }
          }
        }
      }, function(){ cleanupStreamState(); });
    }).catch(function(err){ cleanupStreamState(); throw err; });
  }
})();
</script>
</body>
</html>
